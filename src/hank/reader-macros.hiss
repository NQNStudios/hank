(def-reader-macro "->" (start stream)
    (let (targets
                (hiss-read-delimited-list "\n" ["->"] t nil start stream)
            divert-calls
                (for target targets 'divert))
        (debug-print (cons 
            'begin 
            (case (last targets)
                // tunnel statement:
                (nil
                    (pop! targets)
                    (pop! divert-calls)
                    (zip divert-calls (map targets symbol-name)))
                // chain of diverts, the last of which is final
                (default
                    (pop! divert-calls)
                    (push! divert-calls 'final-divert)
                    (zip divert-calls (map targets symbol-name))))))))
        //(print targets)))
    //`(funcall ,(read-symbol "" stream)))
    // TODO don't just funcall, check the scope tree of divert targets (split by .)
    // TODO diverts should quit when finished unless another -> starts a tunnel or tunnels back

(def-reader-macro "==" (start stream)
    (let (knot-name
                (read-symbol "" stream)
            _
                (HStream:take-line stream)
            knot-body
                (read-all (first (HStream:take-until stream ["=="] nil nil t))))
    
        // Define the knot's function at READ-TIME
        (eval (debug-print `(defun ,knot-name () ,@knot-body (quit))))
        nil))

(defun read-choice (start stream)
    "will be called with start=nil for all choices following the first in a choice point"
    (let (start-char
                (or start (HStream:peek stream 1))
            once-only
                (case start-char
                    ("*" t)
                    ("+" nil))
            depth
                (+ (if start 1 0) (HStream:count-consecutive stream start-char))
            label
                (case 
                    (begin 
                        (HStream:drop-whitespace stream)
                        (HStream:peek stream 1))
                    ("("
                        (trim (substring (first (HStream:take-until stream [")"])) 1))))
            condition
                (case
                    (begin
                        (HStream:drop-whitespace stream)
                        (HStream:peek stream 1))
                    ("{"
                        (hiss-read (trim (substring (first (HStream:take-until stream ["}"])) 1))))
                    (default t))
            output
                (read-output "" stream t)
            on-chosen
                `(begin 
                    ,@(read-all 
                        (first 
                            (HStream:take-until 
                                stream 
                                (cons "=" // stop reading choice point at knot or stitch 
                                    (for delim 
                                        [
                                            (* depth "*") 
                                            (* depth "+")
                                            (* depth "-")
                                        ] 
                                        (+ delim " ")))
                                nil nil t))))) // don't drop the terminator
        (defchoice once-only depth label condition output 0 on-chosen)))


(defun read-choice-point (start stream)
    (let (first-choice
                    (read-choice start stream)
            choices
                [first-choice])
        (while (contains ["*" "+"] (HStream:peek stream 1))
            (push! choices (read-choice nil stream)))
        `(choice-point 
            ',choices
            ,(case (HStream:peek stream 1)
                ("-" nil))))) // TODO decide how much to include in the on-gather */

(set-macro-string "*" read-choice-point)
(set-macro-string "+" read-choice-point)

(defun read-output (start stream &optional choice)
    `(output ,(not choice) ,(HStream:take-line stream "rl")))
    // TODO read the conditional part of choices, 
    // TODO expression insertions, 
    // TODO inline diverts
    // TODO sequences/shuffles

(set-default-read-function read-output)