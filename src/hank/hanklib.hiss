(defun divert (target)
    (funcall (eval (symbol target)))) // TODO resolve the target in scope

(defun final-divert (target)
    (let (exp (+ "STACK-UNWIND (divert \"" target "\")"))
        (error! exp))) // Just trust me on this one

(defun output (direct &rest parts)
    "Evaluate the text of this output, and either send it directly
    to the StoryTeller's callback, or return the result"
    (let (text 
                (apply + 
                    (map parts eval-output-part)))
        (if direct
                (call/cc 
                    (lambda (cc) 
                        (*handle-output*
                            text
                            cc)))
            text)))

// TODO eval-output-part needs to access direct, and if direct, choose what comes after the bracket part. Else choose the bracket part
(defun eval-output-part (part)
    (cond
        ((string? part) part)))

(defstruct choice
    once-only
    depth
    label
    condition
    output
    chosen-count
    on-chosen)
(defvar *choices* [])
(defvar *labeled-choices* (dict))
(defmacro defchoice (&rest args)
    "Define a new choice and return its id"
    `(let (c (make-choice ,@args)
            label (choice-label c)
            id (length *choices*))
        (print c)
        (push! *choices* c)
        (when label (dict-set! *labeled-choices* label c))
        id))

(defun get-player-choice-index (choice-texts)
    (call/cc
        (lambda (cc)
                (*handle-choices* choice-texts cc))))

(defun choice-point (choice-ids on-gather)
    (let (choices // not to be confused with the global list
                (map choice-ids (bind nth *choices*))
            // TODO filter by conditions and chosen counts
            choice-outputs 
                (map choices choice-output)
            choice-texts
                (for o choice-outputs (eval o)))
        (enable-continuations)
        (begin
            (setlocal player-choice-index (print (get-player-choice-index choice-texts)))
            (disable-continuations)

            (let (player-choice
                        (nth choices player-choice-index))
                (choice-set-chosen-count! player-choice (+ 1 (choice-chosen-count player-choice)))
                (eval `(output t ,@(slice (choice-output player-choice) 2)))
                (eval (choice-on-chosen player-choice))))))